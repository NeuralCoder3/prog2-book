<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="remark remark-like"><h3 class="heading">
<span class="type">Remark</span><span class="space"> </span><span class="codenumber">4.3.3</span><span class="period">.</span><span class="space"> </span><span class="title">Imperative variables compared to mathematical variables.</span>
</h3> <div class="para">In functional programming languages as well as in mathematics, variables have a different meaning than in imperative programming languages. Essentially, both paradigms, functional and imperative, agree that variables are immutably bound when they are declared. In functional languages, they are bound to a value, whereas, in imperative programming, the binding is to the address of a container whose content is mutable. Consequently, there are two ways to evaluate a variable in an imperative programming language: To the address of its bound container (L-evaluation) and to its contents (R-evaluation). We discuss these in detail in <a href="sec-c-expr.html#sec-c-lval" class="internal" title="Subsection 4.8.2: L- and R-Evaluation of Expressions">Subsection 4.8.2</a> and <a href="sec-c0.html" class="internal" title="Chapter 6: Formal Semantics">Chapter 6</a>.</div></article><span class="incontext"><a href="sec-c-object.html#bem-c-var" class="internal">in-context</a></span>
</body>
</html>
