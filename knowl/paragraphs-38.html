<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<section class="paragraphs"><h3 class="heading"><span class="title">OCaml.</span></h3> <div class="para">Let us first consider the implementation in OCaml. Functional languages traditionally have good support for implementing data types like the one we need for the AST of our expression language. They provide <dfn class="terminology">Algebraic Data Types</dfn> (not to be confused with <em class="emphasis">abstract</em> data types) which allow the programmer to specify the variants of which the data type is composed. Here <code class="code-inline tex2jax_ignore">Add</code> and <code class="code-inline tex2jax_ignore">Var</code>. The operations that operate on values of that data type typically use <code class="code-inline tex2jax_ignore">match</code> constructs to discriminate the individual cases.</div> <figure class="listing figure-like"><div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;">
<pre class="program"><code class="language-ocaml">type exp =
  | Var of string
  | Add of exp * exp

let rec to_string e = 
  match e with
  | Var v -&gt; v
  | Add (l, r) -&gt; (to_string l) ^ " + " ^ (to_string r)

let rec eval e st =
  match e with
  | Var v -&gt; st v 
  | Add (l, r) -&gt; (eval l st) + (eval r st)
</code></pre>
<a xmlns:mb="https://pretextbook.org/" xmlns:msxsl="urn:schemas-microsoft-com:xslt" style="margin-top:.6em;color: var(--bodytitle);" target="_blank" href="https://v2202201167307177506.ultrasrv.de/editor?code=type%20exp%20%3D%0A%20%20%7C%20Var%20of%20string%0A%20%20%7C%20Add%20of%20exp%20*%20exp%0A%0Alet%20rec%20to_string%20e%20%3D%20%0A%20%20match%20e%20with%0A%20%20%7C%20Var%20v%20-%3E%20v%0A%20%20%7C%20Add%20(l%2C%20r)%20-%3E%20(to_string%20l)%20%5E%20%22%20%2B%20%22%20%5E%20(to_string%20r)%0A%0Alet%20rec%20eval%20e%20st%20%3D%0A%20%20match%20e%20with%0A%20%20%7C%20Var%20v%20-%3E%20st%20v%20%0A%20%20%7C%20Add%20(l%2C%20r)%20-%3E%20(eval%20l%20st)%20%2B%20(eval%20r%20st)%0A%0Alet%20st%20v%20%3D%20if%20v%20%3D%20%22x%22%20then%203%20else%200%3B%3B%0Alet%20e%20%3D%20Add%20(Var%20%22x%22%2C%20Var%20%22x%22)%3B%3B%0Aprint_endline%20(to_string%20e)%3B%3B%0Aprint_endline%20(string_of_int%20(eval%20e%20st))%3B%3B%0A">Run</a>
</div>
<figcaption><span class="type">Listing</span><span class="space"> </span><span class="codenumber">8.10.1<span class="period">.</span></span><span class="space"> </span>Implementation of the abstract syntax of the simple expression language inÂ OCaml.</figcaption></figure></section><span class="incontext"><a href="sec-java-proper-oo.html#paragraphs-38" class="internal">in-context</a></span>
</body>
</html>
