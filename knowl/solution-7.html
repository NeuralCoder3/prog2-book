<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<div class="solution solution-like">
<h4 class="heading">
<span class="type">Solution</span><span class="space"> </span><span class="codenumber">5.1.3.1</span><span class="period">.</span>
</h4>
<div class="code-box" style="width: 100%; margin-left: 0%; margin-right: 0%;">
<pre class="program"><code class="language-c">        struct list_node_t {
            int element;
            struct list_node_t* prev;
            struct list_node_t* next;
        };
        typedef struct list_node_t list_node_t;

        list_node_t* list_root_init(list_node_t** head, list_node_t** tail) {
            *head = NULL;
            *tail = NULL;
        }

        list_node_t* list_prepend_at_head(list_node_t** head, list_node_t** tail,
                                          int element) {
</code></pre>
<a xmlns:mb="https://pretextbook.org/" xmlns:msxsl="urn:schemas-microsoft-com:xslt" style="margin-top:.6em;color: var(--bodytitle);" target="_blank" href="https://prog2.de/book/external/code/c_codecast.html?autocompile=true&amp;code=%0A%20%20%20%20%20%20%20%20struct%20list_node_t%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20int%20element%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20struct%20list_node_t*%20prev%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20struct%20list_node_t*%20next%3B%0A%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20typedef%20struct%20list_node_t%20list_node_t%3B%0A%0A%20%20%20%20%20%20%20%20list_node_t*%20list_root_init(list_node_t**%20head%2C%20list_node_t**%20tail)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20*head%20%3D%20NULL%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20*tail%20%3D%20NULL%3B%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20list_node_t*%20list_prepend_at_head(list_node_t**%20head%2C%20list_node_t**%20tail%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20int%20element)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20list_node_t*%20n%20%3D%20malloc(sizeof(*n))%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20n-%3Eelement%20%20%20%20%20%3D%20element%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20n-%3Eprev%20%20%20%20%20%20%20%20%3D%20NULL%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20n-%3Enext%20%20%20%20%20%20%20%20%3D%20*head%3B%20%2F%2F%20no%20matter%20whether%20%60*head%20%3D%3D%20NULL%60%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(*head%20!%3D%20NULL)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(*head)-%3Eprev%20%3D%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%20%2F%2F%20list%20was%20empty%2C%20now%20singleton%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20assert(*tail%20%3D%3D%20NULL)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20*tail%20%3D%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20*head%20%3D%20n%3B%20%2F%2F%20no%20matter%20whether%20%60*head%20%3D%3D%20NULL%60%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20n%3B%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20list_node_t*%20list_append_at_tail(list_node_t**%20head%2C%20list_node_t**%20tail%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20int%20element)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20list_node_t*%20n%20%3D%20malloc(sizeof(*n))%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20n-%3Eelement%20%20%20%20%20%3D%20element%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20n-%3Eprev%20%20%20%20%20%20%20%20%3D%20*tail%3B%20%2F%2F%20no%20matter%20wheter%20%60*tail%20%3D%3D%20NULL%60%0A%20%20%20%20%20%20%20%20%20%20%20%20n-%3Enext%20%20%20%20%20%20%20%20%3D%20NULL%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(*tail%20!%3D%20NULL)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(*tail)-%3Enext%20%3D%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%20%2F%2F%20list%20was%20empty%2C%20now%20singleton%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20assert(*head%20%3D%3D%20NULL)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20*head%20%3D%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20*tail%20%3D%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20n%3B%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20list_node_t*%20list_prepend_at(list_node_t**%20head%2C%20list_node_t**%20tail%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20list_node_t*%20where%2C%20int%20element)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(where-%3Eprev%20%3D%3D%20NULL)%20%7B%20%2F%2F%20where%20%3D%3D%20*head%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20list_prepend_at_head(head%2C%20tail%2C%20element)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20list_node_t*%20n%20%3D%20malloc(sizeof(*n))%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20n-%3Eelement%20%20%20%20%20%3D%20element%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20n-%3Eprev%20%20%20%20%20%20%20%20%3D%20where-%3Eprev%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20n-%3Enext%20%20%20%20%20%20%20%20%3D%20where%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20where-%3Eprev%20%20%20%20%3D%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20where-%3Eprev-%3Enext%20%3D%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20n%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20list_node_t*%20list_append_at(list_node_t**%20head%2C%20list_node_t**%20tail%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20list_node_t*%20where%2C%20int%20element)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(where-%3Enext%20%3D%3D%20NULL)%20%7B%20%2F%2F%20where%20%3D%3D%20*tail%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20list_append_at_tail(head%2C%20tail%2C%20element)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20list_prepend_at(head%2C%20tail%2C%20where-%3Enext%2C%20element)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20void%20list_remove(list_node_t**%20head%2C%20list_node_t**%20tail%2C%20list_node_t*%20n)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(n-%3Eprev%20!%3D%20NULL)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20n-%3Eprev-%3Enext%20%3D%20n-%3Enext%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%20%2F%2F%20n%20%3D%20*head%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20*head%20%3D%20n-%3Enext%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(n-%3Enext%20!%3D%20NULL)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20n-%3Enext-%3Eprev%20%3D%20n-%3Eprev%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%20%2F%2F%20n%20%3D%20*tail%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20*tail%20%3D%20n-%3Eprev%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20free(n)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20">Run</a>
</div> <ul class="disc">
<li><div class="para">The dummy list node in the other implementation is the analog to the <code class="code-inline tex2jax_ignore">head</code> and <code class="code-inline tex2jax_ignore">tail</code> pointers in this one. But there the first and last list element have pointers to the dummy node, thus it is accessible from within the list. This is not the case when the first and last elements point to <code class="code-inline tex2jax_ignore">NULL</code>, so we have to pass them as double pointers to be able to change them appropriately.</div></li>
<li><div class="para">In the implementation as a ring we can always just append it to the previous list node instead of prepending (or vice versa: instead of appending we could prepend to the next node). Here, the previous (or next) node does not necessarily exist, so there has to be some case distinction.</div></li>
<li><div class="para">Appending to the dummy node is equivalent to <code class="code-inline tex2jax_ignore">list_prepend_at_head</code> and prepending to the dummy node is equivalent to <code class="code-inline tex2jax_ignore">list_append_at_tail</code>. Without (one of) these functions it would not be possible to add the first element to an empty list.</div></li>
</ul>
</div>
<span class="incontext"><a href="sec-ds-lists.html#solution-7" class="internal">in-context</a></span>
</body>
</html>
